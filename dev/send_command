#!/bin/bash
# send_command - Simplified AI player control interface
# Usage: ./send_command [client] <action> [args...]
#   Single-client: ./send_command status
#   Multi-client:  ./send_command runner status
#                  ./send_command corp create-game "Test"

set -euo pipefail
set +H  # Disable history expansion to allow ! in function names

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
AI_EVAL="$SCRIPT_DIR/ai-eval.sh"
TIMEOUT="${TIMEOUT:-20}"
DEBUG="${DEBUG:-0}"  # Set DEBUG=1 to show verbose output

# Multi-client support: detect if first arg is a client name
# Valid client names: runner, corp, or any custom name
# Port mapping: runner=7889 (default), corp=7890
CLIENT_NAME=""
CLIENT_PORT="7889"

# Check if first argument looks like a client name (not a command)
FIRST_ARG="${1:-help}"
if [[ "$FIRST_ARG" =~ ^(runner|corp|[a-z][a-z0-9-]*)$ ]] && [[ ! "$FIRST_ARG" =~ ^(help|status|board|hand|prompt|credits|clicks|archives|log|card-text|hand-text|abilities|list-playables|start-turn|indicate-action|take-credit|draw|end-turn|change|keep-hand|mulligan|discard|play|play-index|run|use-ability|use-runner-ability|trash|rez|fire-subs|let-subs-fire|auto-pass|advance|score|choose|choose-value|continue|jack-out|wait-for-diff|wait-for-log-past|create-game|start-game|leave-game|list-lobbies|join|resync|chat|install|install-index|connect|eval)$ ]]; then
    CLIENT_NAME="$1"
    shift

    # Map client name to port
    case "$CLIENT_NAME" in
        runner)
            CLIENT_PORT="7889"
            ;;
        corp)
            CLIENT_PORT="7890"
            ;;
        *)
            # Custom client, try to find its port by checking what's running
            # Default to 7889 if not specified
            CLIENT_PORT="7889"
            ;;
    esac
fi

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

error() {
    echo -e "${RED}❌ Error: $1${NC}" >&2
    exit 1
}

success() {
    [[ "$DEBUG" == "1" ]] && echo -e "${GREEN}✅ $1${NC}"
    return 0
}

info() {
    [[ "$DEBUG" == "1" ]] && echo -e "${BLUE}ℹ️  $1${NC}"
    return 0
}

warn() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

# Check if AI client is running
check_client() {
    if ! lsof -i :$CLIENT_PORT > /dev/null 2>&1; then
        if [[ -n "$CLIENT_NAME" ]]; then
            error "AI Client REPL '$CLIENT_NAME' not running on port $CLIENT_PORT. Start with: ./dev/start-ai-client-repl.sh $CLIENT_NAME $CLIENT_PORT"
        else
            error "AI Client REPL not running on port $CLIENT_PORT. Start with: ./dev/start-ai-client-repl.sh"
        fi
    fi
}

# Ensure WebSocket connection is active (auto-reconnect if needed)
ensure_connection() {
    # Check if WebSocket client is loaded and connected
    # We check by trying to access the client-state atom which should always exist if loaded
    local check_result=$(TIMEOUT=5 "$AI_EVAL" '(do
      (try
        (require (quote [ai-websocket-client-v2 :as ws]))
        (let [state @ws/client-state
              uid (:uid state)]
          (if uid
            "connected"
            "disconnected"))
        (catch Exception e
          "error")))' 2>&1 | grep -E '^"(connected|disconnected|error)"$' | tr -d '"' || echo "error")

    if [[ "$check_result" != "connected" ]]; then
        # Silently reconnect if needed (check is fragile, so don't warn)
        TIMEOUT=10 "$AI_EVAL" '(do
          (require (quote [ai-websocket-client-v2 :as ws]))
          (ws/connect! "ws://localhost:1042/chsk")
          (Thread/sleep 2000))' > /dev/null 2>&1
        sleep 1
    fi
}

# Show help
show_help() {
    cat << EOF
${BLUE}AI Player Command Interface${NC}

${YELLOW}Multi-Client Usage:${NC}
  ./send_command runner <action> [args...]  - Send command to Runner client (port 7889)
  ./send_command corp <action> [args...]    - Send command to Corp client (port 7890)
  ./send_command <action> [args...]         - Send to default client (backward compatible)

${YELLOW}Examples:${NC}
  ./send_command runner status              - Check Runner's game status
  ./send_command corp create-game "Test"    - Corp creates a game
  ./send_command runner keep-hand           - Runner keeps mulligan
  ./send_command corp start-game            - Corp starts the game

${GREEN}Status Commands:${NC}
  status          - Show game state (turn, credits, clicks, hand size)
  board           - Show full game board (servers, ICE, rigs)
  hand            - Show cards in hand
  prompt          - Show current prompt (if any)
  credits         - Show current credits
  clicks          - Show remaining clicks
  archives        - Show Corp's Archives (faceup/facedown cards)
  log [N]         - Show last N game log entries (default: 20)
  card-text <name>   - Look up card information (type, cost, text)
  abilities <name>   - Show abilities for installed card
  list-playables  - List all currently playable actions (cards, abilities)

${GREEN}Basic Actions:${NC}
  start-turn      - Start your turn (gain clicks, Corp draws card)
  indicate-action - Signal you want to use paid ability (pauses game)
  take-credit     - Spend 1 click to gain 1 credit
  draw            - Spend 1 click to draw 1 card
  end-turn [--force] - End your turn (requires --force if clicks remain)
  smart-end-turn  - Auto-end turn if safe (checks prompts, clicks, EOT triggers)

${GREEN}Mulligan & Hand Management:${NC}
  keep-hand       - Keep starting hand
  mulligan        - Mulligan (redraw) starting hand
  discard         - Auto-discard down to maximum hand size
  discard <name>... - Discard specific cards by name (e.g., discard "Sure Gamble" "Diesel")
  discard <N>...  - Discard specific cards by index (e.g., discard 0 2 4)

${GREEN}Card Actions:${NC}
  play <name>     - Play card by name (e.g., "Sure Gamble")
  play-index <N>  - Play card by index (0-4)
  use-ability <name> <N>  - Use installed card's ability N (e.g., "Smartware Distributor" 0)
  use-runner-ability <name> <N> - Use runner ability on Corp card (e.g., "Brân 1.0" 0 for bioroid)
  trash <name>    - Trash installed card by name (Corp: ICE/asset, Runner: rig)
  rez <name>      - Rez installed Corp card (ICE/asset/upgrade)
  fire-subs <name> - Fire unbroken ICE subroutines (Corp only, during runs)
  auto-pass       - Toggle auto-pass priority during runs (Corp only)
  advance <name>  - Advance installed card (Corp only: agendas, ICE, assets)
  score <name>    - Score agenda with sufficient advancement counters (Corp only)

${GREEN}Runner Actions:${NC}
  run <server>    - Run on server (HQ, "R&D", Archives, remote1, etc.)
  let-subs-fire <name> - Signal intent to let ICE subroutines fire (Runner only, during runs)

${GREEN}Prompts:${NC}
  choose <N>      - Choose option N from current prompt (0, 1, 2...)
  choose-value <text> - Choose option by matching text (e.g., "keep", "steal")
  choose-card <N> - Choose card N from select prompt (for card-targeting effects)
  continue        - Continue/pass priority (for paid ability windows, run phases)
  continue-run    - Smart run handler (auto-continues both players, stops at decisions)
  jack-out        - Jack out of current run (end run unsuccessfully)
  wait-for-diff [seconds] - Wait for game state change (shows recent log)
  wait-for-log-past <marker> [seconds] - Wait for log entries after marker text

${GREEN}Lobby:${NC}
  create-game <title> [side] [precon]  - Create new game (default: "Any Side", "worlds-2012-a")
  start-game      - Start game (after creating and opponent joins)
  auto-start      - Auto-start game if lobby is ready (validates 2 players with valid decks)
  leave-game      - Leave current game lobby
  list-lobbies    - List available games to join
  join <game-id> <side>  - Join game as Runner or Corp
  resync <game-id>       - Rejoin already-started game
  chat <message>         - Send chat message to game

${GREEN}Installation:${NC}
  install <name> [server]  - Install card by name (Corp needs server: HQ, "R&D", "New remote")
  install-index <N> [server] - Install card by index (Corp needs server)

${GREEN}Connection:${NC}
  connect         - Manually reconnect WebSocket to server

${GREEN}Advanced:${NC}
  eval <expr>     - Execute arbitrary Clojure expression

${YELLOW}Examples:${NC}
  ./send_command status
  ./send_command list-lobbies
  ./send_command take-credit
  ./send_command play "Sure Gamble"
  ./send_command install "Daily Casts"
  ./send_command run "R&D"
  ./send_command choose 0
  ./send_command choose-value keep
  ./send_command end-turn

EOF
}

# Execute command via ai-eval.sh
execute() {
    local expr="$1"
    if [[ -n "$CLIENT_NAME" ]]; then
        # Multi-client mode: pass client name and port
        TIMEOUT="$TIMEOUT" "$AI_EVAL" "$CLIENT_NAME" "$CLIENT_PORT" "$expr"
    else
        # Single-client mode: use default (backward compatible)
        TIMEOUT="$TIMEOUT" "$AI_EVAL" "$expr"
    fi
}

# Main command dispatcher
COMMAND="${1:-help}"
shift || true

check_client

case "$COMMAND" in
    # Help
    help|--help|-h)
        show_help
        ;;

    # Connection
    connect)
        info "Reconnecting to game server..."
        execute '(do
          (require (quote [ai-websocket-client-v2 :as ws]))
          (ws/connect! "ws://localhost:1042/chsk")
          (Thread/sleep 2000)
          (println "✅ Connected to ws://localhost:1042/chsk"))'
        ;;

    # Status commands (read-only)
    status)
        execute '(ai-actions/status)'
        ;;

    board)
        execute '(ai-actions/show-board)'
        ;;

    hand)
        execute '(ai-actions/show-hand)'
        ;;

    prompt)
        execute '(ai-actions/show-prompt-detailed)'
        ;;

    credits)
        execute '(ai-actions/show-credits)'
        ;;

    clicks)
        execute '(ai-actions/show-clicks)'
        ;;

    archives)
        execute '(ai-actions/show-archives)'
        ;;

    log)
        N="${1:-20}"
        [[ ! "$N" =~ ^[0-9]+$ ]] && N=20
        execute "(ai-actions/show-log $N)"
        ;;

    card-text)
        CARD_NAME="${1:-}"
        [[ -z "$CARD_NAME" ]] && error "Usage: send_command card-text <card-name>"
        execute "(ai-actions/show-card-text \"$CARD_NAME\")"
        ;;

    hand-text)
        info "Looking up all cards in hand..."
        execute "(ai-actions/show-hand-cards)"
        ;;

    abilities)
        CARD_NAME="${1:-}"
        [[ -z "$CARD_NAME" ]] && error "Usage: send_command abilities <card-name>"
        execute "(ai-actions/show-card-abilities \"$CARD_NAME\")"
        ;;

    list-playables)
        ensure_connection
        info "Listing all playable actions..."
        execute "(ai-actions/list-playables)"
        ;;

    # Basic actions
    start-turn)
        ensure_connection
        info "Starting turn..."
        execute '(ai-actions/start-turn!)'
        ;;

    indicate-action)
        ensure_connection
        info "Indicating paid ability..."
        execute '(ai-actions/indicate-action!)'
        ;;

    take-credit)
        ensure_connection
        info "Taking credit..."
        execute '(ai-actions/take-credit!)'
        ;;

    draw)
        ensure_connection
        info "Drawing card..."
        execute '(ai-actions/draw-card!)'
        ;;

    end-turn)
        ensure_connection
        FORCE=false
        # Check for --force flag
        if [[ "${1:-}" == "--force" ]]; then
            FORCE=true
            info "Ending turn (FORCED - clicks will be wasted)..."
        else
            info "Ending turn..."
        fi
        if [[ "$FORCE" == "true" ]]; then
            execute '(ai-actions/end-turn! :force true)'
        else
            execute '(ai-actions/end-turn!)'
        fi
        ;;

    smart-end-turn)
        ensure_connection
        info "Smart end-turn (auto-detects if safe)..."
        execute '(ai-actions/smart-end-turn!)'
        ;;

    # Dev/Testing commands
    change)
        ensure_connection
        KEY="${1:-}"
        DELTA="${2:-}"
        [[ -z "$KEY" ]] && error "Usage: send_command change <key> <delta>"
        [[ -z "$DELTA" ]] && error "Usage: send_command change <key> <delta>"
        [[ ! "$DELTA" =~ ^-?[0-9]+$ ]] && error "Delta must be a number"
        info "Changing $KEY by $DELTA (dev backdoor)..."
        execute "(ai-actions/change! :$KEY $DELTA)"
        ;;

    # Mulligan
    keep-hand)
        ensure_connection
        info "Keeping hand..."
        execute '(ai-actions/keep-hand)'
        ;;

    mulligan)
        ensure_connection
        info "Taking mulligan..."
        execute '(ai-actions/mulligan)'
        ;;

    discard)
        ensure_connection
        if [[ $# -eq 0 ]]; then
            info "Auto-discarding to hand size..."
            execute '(ai-actions/discard-to-hand-size!)'
        else
            # Check if all args are numeric (indices) or text (card names)
            ALL_NUMERIC=true
            for arg in "$@"; do
                if [[ ! "$arg" =~ ^[0-9]+$ ]]; then
                    ALL_NUMERIC=false
                    break
                fi
            done

            if [[ "$ALL_NUMERIC" == "true" ]]; then
                # Discard by index
                INDICES=("$@")
                info "Discarding cards at indices: ${INDICES[*]}"
                INDICES_VEC="[${INDICES[*]}]"
                execute "(ai-actions/discard-specific-cards! $INDICES_VEC)"
            else
                # Discard by card name
                CARD_NAMES=("$@")
                info "Discarding cards by name: ${CARD_NAMES[*]}"
                # Build Clojure vector of card name strings
                NAMES_VEC="["
                for name in "${CARD_NAMES[@]}"; do
                    NAMES_VEC+="\"$name\" "
                done
                NAMES_VEC+="]"
                execute "(ai-actions/discard-by-names! $NAMES_VEC)"
            fi
        fi
        ;;

    # Card actions
    play)
        ensure_connection
        CARD_NAME="${1:-}"
        [[ -z "$CARD_NAME" ]] && error "Usage: send_command play <card-name>"
        info "Playing card: $CARD_NAME"
        execute "(ai-actions/play-card! \"$CARD_NAME\")"
        ;;

    play-index)
        ensure_connection
        INDEX="${1:-}"
        [[ -z "$INDEX" ]] && error "Usage: send_command play-index <0-4>"
        [[ ! "$INDEX" =~ ^[0-9]+$ ]] && error "Index must be a number"
        info "Playing card at index $INDEX"
        execute "(ai-actions/play-card! $INDEX)"
        ;;

    # Running
    run)
        ensure_connection
        SERVER="${1:-}"
        [[ -z "$SERVER" ]] && error "Usage: send_command run <server>"
        info "Running on $SERVER..."
        execute "(ai-actions/run! \"$SERVER\")"
        ;;

    # Card abilities
    use-ability)
        ensure_connection
        CARD_NAME="${1:-}"
        ABILITY_INDEX="${2:-}"
        [[ -z "$CARD_NAME" ]] && error "Usage: send_command use-ability <card-name> <ability-index>"
        [[ -z "$ABILITY_INDEX" ]] && error "Usage: send_command use-ability <card-name> <ability-index>"
        [[ ! "$ABILITY_INDEX" =~ ^[0-9]+$ ]] && error "Ability index must be a number"
        info "Using ability $ABILITY_INDEX on $CARD_NAME..."
        execute "(ai-actions/use-ability! \"$CARD_NAME\" $ABILITY_INDEX)"
        ;;

    use-runner-ability)
        ensure_connection
        CARD_NAME="${1:-}"
        ABILITY_INDEX="${2:-}"
        [[ -z "$CARD_NAME" ]] && error "Usage: send_command use-runner-ability <card-name> <ability-index>"
        [[ -z "$ABILITY_INDEX" ]] && error "Usage: send_command use-runner-ability <card-name> <ability-index>"
        [[ ! "$ABILITY_INDEX" =~ ^[0-9]+$ ]] && error "Ability index must be a number"
        info "Using runner-ability $ABILITY_INDEX on $CARD_NAME (e.g., bioroid click-to-break)..."
        execute "(ai-actions/use-runner-ability! \"$CARD_NAME\" $ABILITY_INDEX)"
        ;;

    # Trash installed card
    trash)
        ensure_connection
        CARD_NAME="${1:-}"
        [[ -z "$CARD_NAME" ]] && error "Usage: send_command trash <card-name>"
        info "Trashing $CARD_NAME..."
        execute "(ai-actions/trash-installed! \"$CARD_NAME\")"
        ;;

    # Rez Corp card
    rez)
        ensure_connection
        CARD_NAME="${1:-}"
        [[ -z "$CARD_NAME" ]] && error "Usage: send_command rez <card-name>"
        info "Rezzing $CARD_NAME..."
        execute "(ai-actions/rez-card! \"$CARD_NAME\")"
        ;;

    # Fire ICE subroutines
    fire-subs)
        ensure_connection
        ICE_NAME="${1:-}"
        [[ -z "$ICE_NAME" ]] && error "Usage: send_command fire-subs <ice-name>"
        info "Firing unbroken subroutines on $ICE_NAME..."
        execute "(ai-actions/fire-unbroken-subs! \"$ICE_NAME\")"
        ;;

    # Let ICE subroutines fire (Runner)
    let-subs-fire)
        ensure_connection
        ICE_NAME="${1:-}"
        [[ -z "$ICE_NAME" ]] && error "Usage: send_command let-subs-fire <ice-name>"
        info "Signaling intent to let subs fire on $ICE_NAME..."
        execute "(ai-actions/let-subs-fire! \"$ICE_NAME\")"
        ;;

    # Toggle auto-pass priority (Corp)
    auto-pass)
        ensure_connection
        info "Toggling auto-pass priority..."
        execute "(ai-actions/toggle-auto-no-action!)"
        ;;

    # Advance card
    advance)
        ensure_connection
        CARD_NAME="${1:-}"
        [[ -z "$CARD_NAME" ]] && error "Usage: send_command advance <card-name>"
        info "Advancing $CARD_NAME..."
        execute "(ai-actions/advance-card! \"$CARD_NAME\")"
        ;;

    # Score agenda
    score)
        ensure_connection
        CARD_NAME="${1:-}"
        [[ -z "$CARD_NAME" ]] && error "Usage: send_command score <card-name>"
        info "Scoring $CARD_NAME..."
        execute "(ai-actions/score-agenda! \"$CARD_NAME\")"
        ;;

    # Prompts
    choose)
        ensure_connection
        CHOICE="${1:-}"
        [[ -z "$CHOICE" ]] && error "Usage: send_command choose <index>"
        [[ ! "$CHOICE" =~ ^[0-9]+$ ]] && error "Choice must be a number"
        info "Choosing option $CHOICE..."
        execute "(ai-actions/choose-option! $CHOICE)"
        ;;

    choose-value)
        ensure_connection
        VALUE="${1:-}"
        [[ -z "$VALUE" ]] && error "Usage: send_command choose-value <text>"
        info "Choosing option matching: $VALUE..."
        execute "(ai-actions/choose-by-value! \"$VALUE\")"
        ;;

    choose-card)
        ensure_connection
        INDEX="${1:-}"
        [[ -z "$INDEX" ]] && error "Usage: send_command choose-card <index>"
        [[ ! "$INDEX" =~ ^[0-9]+$ ]] && error "Index must be a number"
        info "Choosing card at index $INDEX..."
        execute "(ai-actions/choose-card! $INDEX)"
        ;;

    continue)
        ensure_connection
        info "Passing priority (continue)..."
        execute '(let [state @ai-websocket-client-v2/client-state
                       gameid (:gameid state)]
                  (ai-websocket-client-v2/send-message! :game/action
                    {:gameid (if (string? gameid)
                               (java.util.UUID/fromString gameid)
                               gameid)
                     :command "continue"
                     :args nil})
                  (Thread/sleep 1000))'
        ;;

    continue-run)
        ensure_connection
        info "Auto-handling run (both players)..."
        execute '(ai-actions/continue-run!)'
        ;;

    jack-out)
        ensure_connection
        info "Jacking out of run..."
        execute '(let [state @ai-websocket-client-v2/client-state
                       gameid (:gameid state)]
                  (ai-websocket-client-v2/send-message! :game/action
                    {:gameid (if (string? gameid)
                               (java.util.UUID/fromString gameid)
                               gameid)
                     :command "jack-out"
                     :args nil})
                  (Thread/sleep 1000))'
        ;;

    wait-for-diff)
        ensure_connection
        TIMEOUT="${1:-60}"
        info "Waiting for game state change (timeout: ${TIMEOUT}s)..."
        execute "(ai-actions/wait-for-diff $TIMEOUT)"
        ;;

    wait-for-log-past)
        ensure_connection
        if [ -z "$1" ]; then
            error "Usage: wait-for-log-past <marker-text> [timeout]"
            exit 1
        fi
        MARKER="$1"
        TIMEOUT="${2:-60}"
        info "Waiting for log entries past marker: \"${MARKER}\"..."
        execute "(ai-actions/wait-for-log-past \"$MARKER\" $TIMEOUT)"
        ;;

    # Lobby
    create-game)
        ensure_connection
        TITLE="${1:-AI Test Game}"
        SIDE="${2:-Any Side}"
        PRECON="${3:-worlds-2012-a}"
        info "Creating game: $TITLE (Side: $SIDE)..."
        execute "(do
                   (require (quote [ai-websocket-client-v2 :as ws]))
                   (ws/create-lobby! {:title \"$TITLE\"
                                      :side \"$SIDE\"
                                      :format \"system-gateway\"
                                      :gateway-type \"Beginner\"
                                      :precon \"$PRECON\"
                                      :room \"casual\"
                                      :allow-spectator true
                                      :spectatorhands false
                                      :save-replay false
                                      :api-access false
                                      :password \"\"
                                      :singleton false
                                      :open-decklists false
                                      :turmoil false
                                      :timer nil})
                   (Thread/sleep 2000)
                   (println \"✅ Lobby creation request sent\"))"
        ;;

    start-game)
        ensure_connection
        info "Starting game..."
        execute '(do
                   (require (quote [ai-websocket-client-v2 :as ws]))
                   (let [state @ws/client-state
                         gameid (:gameid state)]
                     (if gameid
                       (do
                         (ws/send-message! :game/start {:gameid gameid})
                         (Thread/sleep 2000)
                         (println "✅ Game start signal sent"))
                       (println "❌ Not in a game lobby"))))'
        ;;

    auto-start)
        ensure_connection
        info "Checking if lobby is ready to auto-start..."
        execute '(ai-actions/auto-start-if-ready!)'
        ;;

    leave-game)
        ensure_connection
        info "Leaving game lobby..."
        execute '(do
                   (require (quote [ai-websocket-client-v2 :as ws]))
                   (let [state @ws/client-state
                         gameid (:gameid state)]
                     (if gameid
                       (do
                         (ws/send-message! :lobby/leave {:gameid gameid})
                         (Thread/sleep 1000)
                         ;; Clear client state after leaving
                         (swap! ws/client-state assoc :gameid nil :side nil)
                         (println "✅ Left game lobby"))
                       (println "⚠️  Not in a game lobby"))))'
        ;;

    list-lobbies)
        ensure_connection
        info "Fetching lobby list..."
        execute '(do
                   (require (quote [ai-websocket-client-v2 :as ws]))
                   (println "Requesting lobby list...")
                   (ws/request-lobby-list!)
                   (Thread/sleep 1000)
                   (ws/show-games))'
        ;;

    join)
        ensure_connection
        GAME_ID="${1:-}"
        SIDE="${2:-Runner}"
        [[ -z "$GAME_ID" ]] && error "Usage: send_command join <game-id> [Runner|Corp]"
        info "Joining game $GAME_ID as $SIDE..."
        execute "(ai-actions/connect-game! \"$GAME_ID\" \"$SIDE\")"
        ;;

    resync)
        ensure_connection
        GAME_ID="${1:-}"
        [[ -z "$GAME_ID" ]] && error "Usage: send_command resync <game-id>"
        info "Resyncing game $GAME_ID..."
        execute "(ai-actions/resync-game! \"$GAME_ID\")"
        ;;

    chat)
        ensure_connection
        MESSAGE="${1:-}"
        [[ -z "$MESSAGE" ]] && error "Usage: send_command chat <message>"
        info "Sending chat message..."
        execute "(ai-actions/send-chat! \"$MESSAGE\")"
        ;;

    # Installation
    install)
        ensure_connection
        CARD_NAME="${1:-}"
        SERVER="${2:-}"
        [[ -z "$CARD_NAME" ]] && error "Usage: send_command install <card-name> [server]"
        if [[ -n "$SERVER" ]]; then
            info "Installing card: $CARD_NAME on $SERVER"
            execute "(ai-actions/install-card! \"$CARD_NAME\" \"$SERVER\")"
        else
            info "Installing card: $CARD_NAME"
            execute "(ai-actions/install-card! \"$CARD_NAME\")"
        fi
        ;;

    install-index)
        ensure_connection
        INDEX="${1:-}"
        SERVER="${2:-}"
        [[ -z "$INDEX" ]] && error "Usage: send_command install-index <0-4> [server]"
        [[ ! "$INDEX" =~ ^[0-9]+$ ]] && error "Index must be a number"
        if [[ -n "$SERVER" ]]; then
            info "Installing card at index $INDEX on $SERVER"
            execute "(ai-actions/install-card! $INDEX \"$SERVER\")"
        else
            info "Installing card at index $INDEX"
            execute "(ai-actions/install-card! $INDEX)"
        fi
        ;;

    # Advanced
    eval)
        EXPR="${1:-}"
        [[ -z "$EXPR" ]] && error "Usage: send_command eval '<clojure-expression>'"
        execute "$EXPR"
        ;;

    # Unknown command
    *)
        error "Unknown command: $COMMAND\nRun './send_command help' for usage"
        ;;
esac
